		EXPORT	arm_addpolycel16, arm_addpolycel32, arm_add4cel4, arm_addgamecel		EXPORT	arm_celinitialisecreation, arm_generatemaps, arm_addcelfrom512map		EXPORT	arm_addcelfrom128map, arm_addcelfrom32map, arm_initialisecache		EXPORT	arm_updatecache, arm_addmonocel, arm_changegamecel					IMPORT	screen_intercept			AREA |c$$code|,CODE,READONLYcel_maxhold	EQU	1024		; Max number of temporary cels allowed - Also in Allocation.h; ---------------------------------------------------------------------------------------------------; SF_ARMCEL; Routines for manipulating and plotting polygons / sprites; All things plotted on the screen must be entered into a linked list of CCB's which are then; plotted in one go ...; Cels cen be added from the 	16x16 sprite list, (for landscape sprites);								32x32 sprite list, (for ship / object textures);								4x4 sprite list, (used to custom build a 16x16 sprite from the map);								game list (fixed game sprites, any size);								512x512 map, 128x128 map or 32x32 map;; For speed, the CCB temporary list is already pre-initialised with the correct flags, when a cel; is added, only the relavent sections of the CCB are updated.; Every time a cel is added to the temporary list, if the maximum is exceeded, the list is plotted; and reset prior to adding the new one.; arm_addpolycel16 -; Passed a pointer to a cel-adder control block (co-ordinates etc.), a pointer to the 16x16; sprite bit-map data, and a texture number, this routine creates a textured 4point polygon which; can have a shade value of 0 (dark) to 7 (brightest); arm_addpolycel32 -; As with arm_polycel16, this routine creates a 4point textured polygon, but is optimised for; applying 32x32 textured sprite; NOTE : If this routine is called with a texture number >160, then arm_addmonocel is called instead; with 160 subtracted for colour lookup, R3 (the plot type) is set to opaque; arm_addgamecel -; Passed a constant game-sprite (number, x, y position, shade value and x&y scales in quad datablock),; adds a constant game-sprite to the plotting list. All sprite references are offset through; an indirection list to allow variable sized sprites.; arm_addmonocel -; Passed a logical colour number in R2, adds a 4point polygon using a 2x2 colour texture from the; palette table. R3 is plot type, 0-Opaque, 1-Transparent; arm_add4cel4 -; This routine is used for distant land plotting, where for speed 16 small landscape sprites are; plotted in one go. Passed a pointer to the map and an x,y position, it first creates a 16x16; uncoded 8bpp sprite containing 16 land sprites (4x4 pixels each), which is then added (as in; arm_addpolycel16); NOTE - These are now cached since they tend to stay on the screen for a while, this saves; building 40k of sprite data per frame; arm_initialisecache -; Sprite data created using arm_add4cel4 is now cached for speed, this routine should be called; at the start of every mission to reset the building cache pointers; arm_celinitialisecreation -; When a cel is created using arm_add4cel4, the sprite data used for the texture is stored in; 'cel_creation'. Each sprite occupies 264 bytes, 8 for the preamble words, and 256 for the sprite; data itself. This routine accepts a pointer to this block of memory, and the number of areas; to pre-initialise (defined as CEL_MAXCREATION in celutils.h). It then initialises the 2 preamble; words at the start of each area, leaving the 256 bytes free to receive a bitmap.;	Cel adder control block [14 words];	----------------------------------; +0	cel_plot counter; +4	x point 1			NOTE :	These 4 screen co-ordinates have their origin at 160,120; +8	y point 1					(screen centre)				; +12	x point 2; +16	y point 2; +20	x point 3; +24	y point 3; +28	x point 4; +32	y point 4; +36	address of cel temporary list; +40	shading value (0 dark, to 7 bright); +44	address of 16bit uncoded palette (128 entries); +48	address of cel creation source block; +52	address of 4x4 compact landscape sprites; +56	address of 16x16 planet landscape texture sprites; +60	address of 32x32 planet object texture sprites; +64	address of fixed game sprites list; +68	address of 512x512 area map; +72	address of 128x128 area map; +76	address of creation cache used block; +80	address of creation cache free list; +84	cache free counter; +88	screen address 0; +92	screen address 1; +96	address of 32x32 area map;	CCB structure : (17 Words MAX);	------------------------------;	uint32 ccb_Flags;						-> Already set up in temporary CCB;	struct CCB *ccb_NextPtr;				-> Set to point to the next temp cel;	CelData    *ccb_SourcePtr;				-> Set to point to the pixel data;	void       *ccb_PLUTPtr;				-> Set to point to the palette lookup;	Coord  ccb_XPos;						-> These are set to wrap to a 4 point polygon;	Coord  ccb_YPos;;	int32  ccb_HDX;;	int32  ccb_HDY;;	int32  ccb_VDX;;	int32  ccb_VDY;;	int32  ccb_HDDX;;	int32  ccb_HDDY;	;	uint32 ccb_PIXC;						-> Set for shading value;	uint32 ccb_PRE0;						-> Ignored (already set in pixel source data);	uint32 ccb_PRE1;						-> Ignored (already set in pixel source data);	int32  ccb_Width;						-> IGNORED;	int32  ccb_Height;						-> IGNORED; ---------------------------------------------------------------------------------------------------;*******************************arm_addpolycel16			ROUT;*******************************; Receives :	R0 = address of cel adder control block; 				R1 = texture number to apply; Returns :		Nothing; 				[ Next temporary cel to add is updated in cel adder control block ]; Corrupts :	r0-r3; ----------		stmfd sp!,{r4-r12,r14}	; Store stack + registers							; ----------		ldr r4,[r0,#0]			; How many cels currently in ?	cmp r4,#cel_maxhold		; Will this one exceed list space ?	blge arm_interceptplot	; Yes, plot and reset list before continuing; ----------	ldr r2,[r0,#56]			; Base address of 16x16 landscape sprites	ldr r4,[r2,r1,asl#2]	; Get offset to spritedata	add r3,r2,r4			; R3 now points to the base of our internal spritedata		ldr r2,[r3],#4			; r2 are FLAGS	ldmia r0,{r4-r12,r14}	; Load in cel setup data	; ----------	ldr r14,[r14,r4,asl #2]	; Get address of THIS temp (Dest) CCB 	(r14) - ccb we are writing to	add r4,r4,#1			; Increment temp pointer	str r4,[r0]				; Store temp pointer; ----------		; This is to get 8 levels of shading using wild and wacky PIXC settings		ldr r4,[r0,#40]			; Load in shade scaling value	subs r4,r4,#1	movmi r4,#0	cmp r4,#8	movgt r4,#8		adr r1,arm_pixc_shade	ldr r4,[r1,r4,asl#2]	; Get the pixc value for this shade		str r4,[r14,#48]		; Store the PIXC Word	str r2,[r14],#8			; Store the control flags		add r2,r3,#32			; Move sourceptr over plot data	stmia r14!,{r2, r3}		; Store SOURCEPTR then PLUTPTR; ----------; STAGE 1 - X,Y Start position	mov r0,#160<<16			; Centre x value	add r0,r0,r5,asl #16;		mov r1,#120<<16			; Centre y value	add r1,r1,r6,asl #16;; ----------; STAGE 2 - Calculate horizontal scale values		sub r2,r7,r5	mov r2,r2,asl #16		sub r3,r8,r6	mov r3,r3,asl #16		stmia r14!,{r0-r3}; ----------; STAGE 3 - Calculate vertical scale values		sub r0,r11,r5	mov r0,r0,asl #12		sub r1,r12,r6	mov r1,r1,asl #12; ----------; STAGE 4 - Calculate horizontal / vertical scale increment values	sub r2,r9,r11	sub r2,r2,r7	add r2,r2,r5	mov r2,r2,asl #12		sub r3,r10,r12	sub r3,r3,r8	add r3,r3,r6	mov r3,r3,asl #12	stmia r14!,{r0-r3}; ----------	ldmfd sp!,{r4-r12,pc}^	; Exit routine				;*******************************arm_addpolycel32			ROUT;*******************************; Receives :	R0 = address of cel adder control block; 				R1 = texture number to apply; Returns :		Nothing; 				[ Next temporary cel to add is updated in cel adder control block ]; Corrupts :	r0-r3; ----------		subs r2,r1,#160				; Are we adding a monochrome cel ?	bpl arm_addmonocel_opaque	; Yes, call monocel routine		stmfd sp!,{r4-r12, r14}	; Store stack + registers						; ----------	ldr r4,[r0,#0]			; How many cels currently in ?	cmp r4,#cel_maxhold		; Will this one exceed list space ?	blge arm_interceptplot	; Yes, plot and reset list before continuing; ----------	ldr r2,[r0,#60]			; Base address of 32x32 object texture sprites	ldr r4,[r2,r1,asl#2]	; Get offset to spritedata	add r3,r2,r4			; R3 now points to the base of our internal spritedata	ldmia r0,{r4-r12,r14}	; Load in cel setup data	; ----------	ldr r14,[r14,r4,asl #2]	; Get address of THIS temp (Dest) CCB 	(r14) - ccb we are writing to	add r4,r4,#1			; Increment temp pointer	str r4,[r0]				; Store temp pointer; ----------		ldr r4,[r0,#40]			; Load in shade scaling value	subs r4,r4,#1	movmi r4,#0	cmp r4,#8	movgt r4,#8		adr r2,arm_pixc_shade	ldr r4,[r2,r4,asl#2]	; Get the pixc value for this shade	str r4,[r14,#48]		; Store the PIXC Word		ldmia r3!,{r0,r2}		; R0 is size shift in bits, R2 is FLAGS for sprite	str r2,[r14],#8			; Store the control flags	str r3,[r14],#8			; Store SOURCEPTR; ----------; STAGE 1 - Calculate horizontal scale values		; Work out bitshift value for size		rsb r1,r0,#18		sub r3,r7,r5	mov r3,r3,asl r1		sub r4,r8,r6	mov r4,r4,asl r1; ----------; STAGE 2 - X,Y Start position	mov r1,#160<<16			; Centre x value	add r1,r1,r5,asl #16;		mov r2,#120<<16			; Centre y value	add r2,r2,r6,asl #16;	stmia r14!,{r1-r4}; ----------; STAGE 3 - Calculate horizontal / vertical scale increment values	; Work out bitshift value for size		mov r1,r0, asl#1	rsb r1,r1,#16		sub r3,r9,r11	sub r3,r3,r7	add r3,r3,r5	mov r3,r3,asl r1		sub r4,r10,r12	sub r4,r4,r8	add r4,r4,r6	mov r4,r4,asl r1; ----------; STAGE 4 - Calculate vertical scale values		; Work out bitshift value for size		rsb r0,r0,#14		sub r1,r11,r5	mov r1,r1,asl r0		sub r2,r12,r6	mov r2,r2,asl r0	stmia r14!,{r1-r4}; ----------	ldmfd sp!,{r4-r12,pc}^	; Exit routine	;*******************************arm_addgamecel				ROUT;*******************************; Receives :	R0 = address of cel adder control block; 				R1 = game sprite number to add to plotting list;				R2 = X Scale value (1024 = Normal Scale);				R3 = Y Scale value (1024 = Normal Scale); Returns :		Nothing; 				[ Next temporary cel to add is updated in cel adder control block ]; Corrupts :	r0-r3; ----------	stmfd sp!,{r4-r10, r14}	; Store stack + registers								; ----------		ldr r4,[r0,#0]			; How many cels currently in ?	cmp r4,#cel_maxhold		; Will this one exceed list space ?	blge arm_interceptplot	; Yes, plot and reset list before continuing; ----------	ldr r4,[r0,#64]			; Base address of constant game sprites	ldr r1,[r4,r1,asl #2]	; Get offset to actual sprite data start	add r1,r4,r1			; R1 now contains actual address of Flags control word	ldmia r1!,{r6,r7}		; r6 = PIXC Control, r7 = Flags, R1 now points to start of sprite data; ----------	ldr r4,[r0,#0]			; temp cel counter	ldr r5,[r0,#36]			; address of temp plotting ccb list	ldr r10,[r5,r4,asl #2]	; Get address of THIS temp (Dest) CCB 	(r5) - ccb we are writing to	add r4,r4,#1			; Increment temp pointer	str r4,[r0]				; Store temp pointer; ----------	str r6,[r10,#48]		; Store the PIXC Word	str r7,[r10],#8			; Store Flags word	str r1,[r10],#8			; Store SourcePtr; ----------; STAGE 1 - X,Y Start position	ldmib r0,{r0,r1}		; Get x and y position		add r0,r0,#160			; Centre x value	mov r0,r0,asl #16		; Scale up X position		add r1,r1,#120			; Centre y value	mov r1,r1,asl #16		; Scale up Y position; ----------; STAGE 2 - Calculate horizontal scale values		mov r4,r2, asl#10	mov r5,#0	; ----------; STAGE 3 - Calculate vertical scale values	mov r6,#0	mov r7,r3,asl #6; ----------; STAGE 4 - Calculate horizontal / vertical scale increment values	mov r8,#0	mov r9,#0	stmia r10!,{r0-r1,r4-r9}	; ----------	ldmfd sp!,{r4-r10, pc}^	; Exit routine; ----------99		DCD 0					; Stack store;*******************************arm_addmonocel_opaque		ROUT;*******************************; This is a drop through to add monocel, setting opaque plotting (if called from arc_addcel32)	mov r3,#0;*******************************arm_addmonocel				ROUT;*******************************; Receives :	R0 = address of cel adder control block;				R1 = UNUSED; 				R2 = Logical Colour Number (0-x);				R3 = Plot type, (0) - Opaque,;								(1) - Transparent; Returns :		Nothing; 				[ Next temporary cel to add is updated in cel adder control block ]; Corrupts :	r0-r3; ----------		stmfd sp!,{r4-r12, r14}	; Store stack + registers						; ----------	ldr r4,[r0,#0]			; How many cels currently in ?	cmp r4,#cel_maxhold		; Will this one exceed list space ?	blge arm_interceptplot	; Yes, plot and reset list before continuing; ----------	ldr r1,[r0,#44]			; Base address palette entries	add r2,r1,r2,asl#3		; R2 now points to actual palette sprite pixel entry	ldmia r0,{r4-r12,r14}	; Load in cel setup data; ----------	ldr r14,[r14,r4,asl #2]	; Get address of THIS temp (Dest) CCB 	(r14) - ccb we are writing to	add r4,r4,#1			; Increment temp pointer	str r4,[r0]				; Store temp pointer	; ----------		ldr r4,arm_cel_setccbflag_monochrome	; Get Flags	str r4,[r14],#8							; Store flags	str r2,[r14],#8							; Store SOURCEPTR	ldr r4,[r0,#40]			; Load in shade scaling value	cmp r4,#7				; cap shading value	movgt r4,#7	cmp r4,#0	movlt r4,#0	orr r4,r4,r3,asl#3		; Put plotting type flags in top bits of r4	; ----------; STAGE 1 - X,Y Start position	mov r0,#160<<16			; Centre x value	add r0,r0,r5,asl #16;		mov r1,#120<<16			; Centre y value	add r1,r1,r6,asl #16;; ----------; STAGE 2 - Calculate horizontal scale values		sub r2,r7,r5	mov r2,r2,asl #20		sub r3,r8,r6	mov r3,r3,asl #20		stmia r14!,{r0-r3}; ----------; STAGE 3 - Calculate vertical scale values		sub r0,r11,r5	mov r0,r0,asl #16		sub r1,r12,r6	mov r1,r1,asl #16; ----------; STAGE 4 - Calculate horizontal / vertical scale increment values	sub r2,r9,r11	sub r2,r2,r7	add r2,r2,r5	mov r2,r2,asl #20		sub r3,r10,r12	sub r3,r3,r8	add r3,r3,r6	mov r3,r3,asl #20; ----------; STAGE 5 - Insert LDPIXC shading values	tst r4,#2_1000			; Are we plotting transparent monochrome polygon ?	and r4,r4,#7			; Just get shading value in r4		mov r4,r4,lsl #10		; Scale up PMV	orr r4,r4,#3<<8			; Set PDV to divide by 8		orrne r4,r4,#1<<7		; Yes, polygon in transparent, set 2nd source	orrne r4,r4,#1			; and 2nd divider to 2; ----------; STAGE 6 - Create preamble 0 and preamble 1 words	mov r5,#(1<<4)+(1<<3)+6	; UNCODED, REP8, 16BPP	mov r6,#0		stmia r14!,{r0-r6}; ----------	ldmfd sp!,{r4-r12,pc}^	; Exit routine;*******************************arm_add4cel4				ROUT;*******************************; Receives :	R0 = address of cel adder control block; 				R1 = address of map;				R2 = x position on map;				R3 = y position on map; Returns :		Nothing; 				[ Next temporary cel to add is updated in cel adder control block ];				[ Next cel creation counter is updated]; Corrupts :	r0-r3; ----------		stmfd sp!,{r4-r12, r14}	; Store stack + registers	str sp,%99	; ----------	ldr r4,[r0,#0]			; How many cels currently in ?	cmp r4,#cel_maxhold		; Will this one exceed list space ?	blge arm_interceptplot	; Yes, plot and reset list before continuing	; ----------	add r5,r0,#48			; Point to creation data in cel_quad block		ldr r4,[r0,#76]			; Is the cel already in the cache ?		mov r6,r2,asr #2		; x quad pos	mov r7,r3,asr #2		; y quad pos	add r4,r4,r6,asl #1	add r4,r4,r7,asl #7		; r4 is cache datablock address	ldrb r9,[r4,#0]			; Get the cache-frame counter - 		cmp r9,#0	beq addcel4x4cache_miss	; The sprite is not cached, build it	; ----------		mov r6,#2				; The sprite is cached !	strb r6,[r4,#0]			; Reset its frame - used counter	ldrb r9,[r4,#1]			; r9 now holds the source number		ldmia r5,{r6}		add r2,r6,r9, asl#8		; Pointer to where the texture is	add r2,r2,r9, asl#3	b addcel4x4registercache	; We have got sprite from cache - just add it; ----------addcel4x4cache_miss			; We are now creating a sprite and putting it in the cache list		ldr r9,[r0,#84]				; Get cache free count	subs r9,r9,#1	ldmmifd sp!,{r4-r12, pc}^	; No room in the cache - this should not happen, but just in case ..	str r9,[r0,#84]		mov r6,#2	strb r6,[r4,#0]			; Mark cache lookup frame as used		ldr r6,[r0,#80]			; Cache free address list	ldrb r9,[r6,r9]			; Get free source number	strb r9,[r4,#1]			; Store it in cache ref block		ldmia r5,{r6,r7}	add r6,r6,r9, asl#8		; Pointer to where the texture is going to be	add r6,r6,r9, asl#3	add r6,r6,#8	; ----------			mov r9,#4	; ----------addcel4x4yloop	subs r9,r9,#1			; dec y	bmi addcel4x4register	mov r8,#4; ----------addcel4x4xloop	subs r8,r8,#1			; dec x	bmi addcel4x4yloop	add r12,r2,r8			; get actual x pos in map	(no overflow check - assumed quad aligned)	add r13,r3,r9			; get actual y pos in map	("")			add r12,r12,r13,asl#8	ldrb r12,[r1,r12]		; get actual sprite in map position		add r12,r7,r12,asl#4	; point to start address of that compacted sprite		add r10,r6,r9,asl#6		ldmia r12,{r11-r14}		; get its sprite data		str r14,[r10,r8,asl#2]!	; store 1st word of sprite	str r13,[r10,#16]		; store 2nd word of sprite	str r12,[r10,#32]		; store 3rd word of sprite	str r11,[r10,#48]		; store 4th word of sprite		b addcel4x4xloop; ----------addcel4x4register		sub r2,r6,#8			; pointer to source data in r2addcel4x4registercache; ----------		ldmia r0,{r4-r13}		; Load in cel setup data	ldr r14,[r13,r4,asl #2]	; Get address of THIS temp (Dest) CCB 	(r14) - ccb we are writing to	add r4,r4,#1			; Increment temp pointer	str r4,[r0]				; Store temp pointer; ----------	ldr r4,[r0,#40]			; Shading value	subs r4,r4,#1	movmi r4,#0	cmp r4,#8	movgt r4,#8		adr r0,arm_pixc_shade	ldr r4,[r0,r4,asl#2]			; Get the pixc value for this shade	str r4,[r14,#48]				; Store the PIXC Word	ldr r4,arm_cel_setccbflag_4x4	; Get Flags	str r4,[r14],#8					; Store FLAGS	str r2,[r14],#8					; Store SOURCEPTR; ----------; STAGE 1 - X,Y Start position	mov r0,#160<<16			; Centre x value	add r0,r0,r5,asl #16;		mov r1,#120<<16			; Centre y value	add r1,r1,r6,asl #16;; ----------; STAGE 2 - Calculate horizontal scale values		sub r2,r7,r5	mov r2,r2,asl #16		sub r3,r8,r6	mov r3,r3,asl #16		stmia r14!,{r0-r3}; ----------; STAGE 3 - Calculate vertical scale values		sub r0,r11,r5	mov r0,r0,asl #12		sub r1,r12,r6	mov r1,r1,asl #12; ----------; STAGE 4 - Calculate horizontal / vertical scale increment values	sub r2,r9,r11	sub r2,r2,r7	add r2,r2,r5	mov r2,r2,asl #12		sub r3,r10,r12	sub r3,r3,r8	add r3,r3,r6	mov r3,r3,asl #12	stmia r14!,{r0-r3}; ----------	ldr sp,%99	ldmfd sp!,{r4-r12, pc}^	; Exit routine; ----------99		DCD 0					; Stack store				; ---------------------------------------------------------------------------------------------------arm_cel_setccbflag_monochrome	DCD	2_00111111011001100100000100110000arm_cel_setccbflag_4x4	DCD	2_00111111001001100100010100110000arm_cel_setccbflag_frommap	DCD	2_00111111011001100100010100110000	arm_pixc_shade; Shading control values for P modes 0 and 1 (currently only P mode 0)    DCD (1<<13) + 1                                      ; 25%   (0)    DCD (1<<13) + (3<<8) + 1                             ; 50%   (1)    DCD (1<<13) + (3<<8) + (3<<6) + (2<<4) + 1           ; 75%   (2)    DCD (1<<13) + (3<<8)	                             ; 100%  (3)    DCD (1<<13) + (2<<8) + (3<<6) + (2<<4) + 1           ; 125%  (4)    DCD (1<<13) + (2<<8) + (3<<6) + (1<<4) + 1           ; 150%  (5)    DCD (1<<13) + (1<<8) + (3<<6) + (2<<4) + (1<<1) + 1  ; 175%  (6)    DCD (1<<13) + (1<<8) + 1                             ; 200%  (7)    DCD (1<<13) + (1<<8) + (3<<6) + (2<<4) + 1           ; 225%  (8); ---------------------------------------------------------------------------------------------------;*******************************arm_addcelfrom512map		ROUT;*******************************; Adds a cel to temporary list clipped from the 512x512 map; ----------; Receives :	R0 = address of cel adder control block;				R1 = x position in map (0-255);				R2 = y position in map (0-255);				R3 = size of block to render				(0) - 8x8 pixels;															(1) - 16x16 pixels;															(2) - 32x32 pixels;															(3) - 64x64 pixels;															(4) - 128x128 pixels;															(5) - 256x256 pixels;															(6) - 512x512 pixels; Returns :		Nothing;				[ Next temporary cel to add is updated in cel adder control block ]; Corrupts :	?; ----------		stmfd sp!,{r4-r12, r14}	; Store stack + registers	str sp,%99 									; ----------	ldr r4,[r0,#0]			; How many cels currently in ?	cmp r4,#cel_maxhold		; Will this one exceed list space ?	blge arm_interceptplot	; Yes, plot and reset list before continuing	; ----------		ldr r4,[r0,#68]			; Find start address in base map	add r1,r4,r1,asl#1		; add x*2	add r1,r1,r2,asl#10		; add y*1024	ldmia r0,{r4-r13}		; Load in cel setup data; ----------	ldr r14,[r13,r4,asl #2]	; Get address of THIS temp (Dest) CCB 	(r14) - ccb we are writing to	add r4,r4,#1			; Increment temp pointer	str r4,[r0]				; Store temp pointer; ----------		ldr r4,[r0,#40]			; Load in shade scaling value	subs r4,r4,#1	movmi r4,#0	cmp r4,#8	movgt r4,#8		adr r2,arm_pixc_shade	ldr r4,[r2,r4,asl#2]	; Get the pixc value for this shade	ldr r2,arm_cel_setccbflag_frommap		; Get Flags	str r2,[r14],#8							; Store FLAGS	str r1,[r14],#8							; Store SOURCEPTR	; ----------; STAGE 1 - X,Y Start position	mov r0,#160<<16			; Centre x value	add r0,r0,r5,asl #16;		mov r1,#120<<16			; Centre y value	add r1,r1,r6,asl #16;	stmia r14!,{r0-r1}	; ----------; STAGE 2 - Calculate horizontal scale values - (Depends on size of source)		rsb r2,r3,#16		sub r0,r7,r5	mov r0,r0,asl r2		sub r1,r8,r6	mov r1,r1,asl r2		stmia r14!,{r0-r1}; ----------; STAGE 3 - Calculate vertical scale values - (Depends on size of source)		rsb r2,r3,#12		sub r0,r11,r5	mov r0,r0,asl r2		sub r1,r12,r6	mov r1,r1,asl r2	stmia r14!,{r0-r1}	; ----------; STAGE 4 - Calculate horizontal / vertical scale increment values - (Depends on size of source)	mov r2,r3,asl#1	rsb r2,r2,#12		sub r0,r9,r11	sub r0,r0,r7	add r0,r0,r5	mov r0,r0,asl r2		sub r1,r10,r12	sub r1,r1,r8	add r1,r1,r6	mov r1,r1,asl r2; ----------; STAGE 5 - Insert PIXC (Already Calculated) and Preamble words 0 and 1	mov r6,#1					; Calculate x&y size of source subrectangle block (15, 31, 63, 127 etc.)	add r5,r3,#4	mov r6,r6,asl r5	sub r6,r6,#1		mov r5,#1<<30				; Calculate preamble word 0	orr r5,r5,r6,asl#6	orr r5,r5,#5		orr r6,r6,#126<<16			; Calculate preamble word 1	stmia r14!,{r0-r1, r4-r6}	; Store preamble words	; ----------	ldr sp,%99	ldmfd sp!,{r4-r12,pc}^	; Exit routine; ----------99		DCD 0					; Stack store							;*******************************arm_addcelfrom128map		ROUT;*******************************; Adds a cel to temporary list clipped from the 128x128 map; ----------; Receives :	R0 = address of cel adder control block;				R1 = x position in map (0-255);				R2 = y position in map (0-255);				R3 = size of block to render; Returns :		Nothing;				[ Next temporary cel to add is updated in cel adder control block ]; Corrupts :	?; ----------		stmfd sp!,{r4-r12, r14}	; Store stack + registers	str sp,%99 									; ----------	ldr r4,[r0,#0]			; How many cels currently in ?	cmp r4,#cel_maxhold		; Will this one exceed list space ?	blge arm_interceptplot	; Yes, plot and reset list before continuing; ----------	ldr r4,[r0,#72]			; Find start address in base map	add r1,r4,r1,asr#1		; add x/2	mov r2,r2,asr#1	add r1,r1,r2,asl#7		; add y*128	ldmia r0,{r4-r13}		; Load in cel setup data; ----------	ldr r14,[r13,r4,asl #2]	; Get address of THIS temp (Dest) CCB 	(r14) - ccb we are writing to	add r4,r4,#1			; Increment temp pointer	str r4,[r0]				; Store temp pointer; ----------		ldr r4,[r0,#40]			; Load in shade scaling value	subs r4,r4,#1	movmi r4,#0	cmp r4,#8	movgt r4,#8		adr r2,arm_pixc_shade	ldr r4,[r2,r4,asl#2]	; Get the pixc value for this shade	ldr r2,arm_cel_setccbflag_frommap		; Get Flags	str r2,[r14],#8							; Store FLAGS	str r1,[r14],#8							; Store SOURCEPTR; ----------; STAGE 1 - X,Y Start position	mov r0,#160<<16			; Centre x value	add r0,r0,r5,asl #16;		mov r1,#120<<16			; Centre y value	add r1,r1,r6,asl #16;	stmia r14!,{r0-r1}	; ----------; STAGE 2 - Calculate horizontal scale values - (Depends on size of source)		rsb r2,r3,#18		sub r0,r7,r5	mov r0,r0,asl r2		sub r1,r8,r6	mov r1,r1,asl r2		stmia r14!,{r0-r1}; ----------; STAGE 3 - Calculate vertical scale values - (Depends on size of source)		rsb r2,r3,#14		sub r0,r11,r5	mov r0,r0,asl r2		sub r1,r12,r6	mov r1,r1,asl r2	stmia r14!,{r0-r1}	; ----------; STAGE 4 - Calculate horizontal / vertical scale increment values - (Depends on size of source)	mov r2,r3,asl #1	rsb r2,r2,#16		sub r0,r9,r11	sub r0,r0,r7	add r0,r0,r5	mov r0,r0,asl r2		sub r1,r10,r12	sub r1,r1,r8	add r1,r1,r6	mov r1,r1,asl r2; ----------; STAGE 5 - Insert PIXC (Already Calculated) and Preamble words 0 and 1	mov r6,#1					; Calculate x&y size of source subrectangle block (15, 31, 63, 127 etc.)	add r5,r3,#2	mov r6,r6,asl r5	sub r6,r6,#1		mov r5,#1<<30				; Calculate preamble word 0	orr r5,r5,r6,asl#6	orr r5,r5,#5		orr r6,r6,#30<<16			; Calculate preamble word 1	stmia r14!,{r0-r1, r4-r6}	; Store preamble words	; ----------	ldr sp,%99	ldmfd sp!,{r4-r12,pc}^	; Exit routine; ----------99		DCD 0					; Stack store;*******************************arm_addcelfrom32map			ROUT;*******************************; Adds a cel to temporary list clipped from the 32x32 map; ----------; Receives :	R0 = address of cel adder control block;				R1 = x position in map (0-255);				R2 = y position in map (0-255);				R3 = size of block to render; Returns :		Nothing;				[ Next temporary cel to add is updated in cel adder control block ]; Corrupts :	?; ----------		stmfd sp!,{r4-r12, r14}	; Store stack + registers	str sp,%99 									; ----------	ldr r4,[r0,#0]			; How many cels currently in ?	cmp r4,#cel_maxhold		; Will this one exceed list space ?	blge arm_interceptplot	; Yes, plot and reset list before continuing; ----------	ldr r4,[r0,#96]			; Find start address in base map	add r1,r4,r1,asr#3		; add x/8	mov r2,r2,asr#3	add r1,r1,r2,asl#5		; add y*32	ldmia r0,{r4-r13}		; Load in cel setup data; ----------	ldr r14,[r13,r4,asl #2]	; Get address of THIS temp (Dest) CCB 	(r14) - ccb we are writing to	add r4,r4,#1			; Increment temp pointer	str r4,[r0]				; Store temp pointer; ----------		ldr r4,[r0,#40]			; Load in shade scaling value	subs r4,r4,#1	movmi r4,#0	cmp r4,#8	movgt r4,#8		adr r2,arm_pixc_shade	ldr r4,[r2,r4,asl#2]	; Get the pixc value for this shade	ldr r2,arm_cel_setccbflag_frommap		; Get Flags	str r2,[r14],#8							; Store FLAGS	str r1,[r14],#8							; Store SOURCEPTR	; ----------; STAGE 1 - X,Y Start position	mov r0,#160<<16			; Centre x value	add r0,r0,r5,asl #16;		mov r1,#120<<16			; Centre y value	add r1,r1,r6,asl #16;	stmia r14!,{r0-r1}	; ----------; STAGE 2 - Calculate horizontal scale values - (Depends on size of source)		rsb r2,r3,#20		sub r0,r7,r5	mov r0,r0,asl r2		sub r1,r8,r6	mov r1,r1,asl r2		stmia r14!,{r0-r1}; ----------; STAGE 3 - Calculate vertical scale values - (Depends on size of source)		rsb r2,r3,#16		sub r0,r11,r5	mov r0,r0,asl r2		sub r1,r12,r6	mov r1,r1,asl r2	stmia r14!,{r0-r1}	; ----------; STAGE 4 - Calculate horizontal / vertical scale increment values - (Depends on size of source)	mov r2,r3,asl #1	rsb r2,r2,#20		sub r0,r9,r11	sub r0,r0,r7	add r0,r0,r5	mov r0,r0,asl r2		sub r1,r10,r12	sub r1,r1,r8	add r1,r1,r6	mov r1,r1,asl r2; ----------; STAGE 5 - Insert PIXC (Already Calculated) and Preamble words 0 and 1	mov r6,#1					; Calculate x&y size of source subrectangle block (15, 31, 63, 127 etc.)	mov r6,r6,asl r3	sub r6,r6,#1		mov r5,#1<<30				; Calculate preamble word 0	orr r5,r5,r6,asl#6	orr r5,r5,#5		orr r6,r6,#6<<16			; Calculate preamble word 1	stmia r14!,{r0-r1, r4-r6}	; Store preamble words	; ----------	ldr sp,%99	ldmfd sp!,{r4-r12,pc}^	; Exit routine; ----------99		DCD 0					; Stack store;*******************************arm_celinitialisecreation	ROUT;*******************************; Receives :	R0 = address of creation sprite block; 				R1 = Number of sprite blocks to initialise; Returns :		Nothing; Corrupts :	r0-r3	; ----------		sub r1,r1,#1		mov r2,#15 << 6			; Preamble word 0 (16x16 8bpp coded cel)	orr r2,r2,#5		mov r3,#2 << 16			; Preamble word 1 (16x16 8bpp coded cel)	orr r3,r3,#1 << 12	orr r3,r3,#15; ----------arm_initialisecreationloop	subs r1,r1,#1	movmis pc,r14	stmia r0,{r2,r3}	add r0,r0,#264	b arm_initialisecreationloop;*******************************arm_initialisecache 		ROUT;*******************************; Receives :	R0 = Address of cel adder control block	; Returns :		Nothing; Corrupts :	r0-r3	; ----------	ldr r3,[r0,#76]			; Get address of cache_lookup block	mov r2,#0	mov r1,#0; ----------				; Clear the cache lookup blockarm_initialisecacheblockloop	str r2,[r3,r1]	add r1,r1,#4	cmp r1,#8192	blt arm_initialisecacheblockloop	mov r1,#255	str r1,[r0,#84]			; Store number of free cel blocks	ldr r3,[r0,#80]			; Get address of cache_free list	; ----------				; Clear the cache lookup blockarm_initialisecachefreeloop	subs r1,r1,#1	movmis pc,r14			; Exit		strb r1,[r3,r1]			; Store free slot in free list	b arm_initialisecachefreeloop	;*******************************arm_updatecache 			ROUT;*******************************; Receives :	R0 = Address of cel adder control block	; Returns :		Nothing; Corrupts :	r0-r3	; ----------	stmfd sp!,{r4-r6}		add r1,r0,#76	ldmia r1,{r1,r2,r3}		; Get addresses							; r1 = cache_lookup block address							; r2 = cache_free list address							; r3 = cache free count								add r4,r1,#(64*64)*2	; point at endarm_updatecacheloop	cmp r4,r1	blt arm_updatecacheexit;	; ----------	ldr r5,[r4,#-4]!		; Get 2 cache entries	cmp r5,#0	beq arm_updatecacheloop	; They are both empty, carry on looking		; ----------	; Update timer entry for cache entry 1 (if valid)		mov r6,r5, lsr#8	and r6,r6,#255				; Get timer entry from word	subs r6,r6,#1	strgeb r6,[r4,#2]			; If still valid, store new counter value	; Timer has expired (if equal to zero) for cache entry 1, delete it	streqb r6,[r4,#3]			; Clear source entry	streqb r5,[r2,r3]			; Put entry in free list	addeq r3,r3,#1; ----------	; Update timer entry for cache entry 1 (if valid)		mov r5,r5, lsr #16		mov r6,r5, lsr#8	and r6,r6,#255				; Get timer entry from word	subs r6,r6,#1	strgeb r6,[r4,#0]			; If still valid, store new counter value	bne arm_updatecacheloop		; carry on search		; Timer has expired (if equal to zero) for cache entry 2, delete it	strb r6,[r4,#1]				; Clear source entry	strb r5,[r2,r3]				; Put entry in free list	add r3,r3,#1	b arm_updatecacheloop	; carry on search; ----------arm_updatecacheexit	str r3,[r0,#84]		; End of scan, put new free counter back	ldmfd sp!,{r4-r6}	movs pc,r14	;*******************************arm_generatemaps			ROUT;*******************************; Receives :	R0 = address of cel data block;				R1 = address of actual spritemap; Returns :		Nothing; 				[ Next temporary cel to add is updated in cel adder control block ]; Corrupts :	r0-r3; ----------	stmfd sp!,{r4-r12,r14}		ldr r2,[r0,#52]		; address of 4x4 compact landscape sprites	ldr r9,[r0,#72]		; address of 128x128 area map	ldr r10,[r0,#96]	; address of 32x32 area map	ldr r0,[r0,#68]		; address of 512x512 area map	mov r3,#256; ----------arm_generatemaps_yloop	subs r3,r3,#1	ldmmifd sp!,{r4-r12,pc}^	mov r4,#256; ----------arm_generatemaps_xloop	subs r4,r4,#1	bmi arm_generatemaps_yloop		; Get sprite from map		add r5,r4,r3,asl#8	; Get position in map	ldrb r5,[r1,r5]		; get actual sprite from map	add r6,r2,r5,asl#4	; point to actual 4x4 sprite		; Generate 128x128 map image			mov r7,r3,asr#1	mov r8,r4,asr#1		add r7,r8,r7,asl#7	; point to correct address in 128x128 map		ldrb r8,[r6,#0]		; get top left pixel from 4x4 sprite in actual map	strb r8,[r9,r7]		; store pixel in 128x128 map	; Generate 32x32 map image			mov r7,r3,asr#3	mov r8,r4,asr#3		add r7,r8,r7,asl#5	; point to correct address in 32x32 map		ldrb r8,[r6,#0]		; get top left pixel from 4x4 sprite in actual map	strb r8,[r10,r7]	; store pixel in 32x32 map		; Generate 512x512 map image			add r7,r0,r3,asl#10	; point to correct address in 512x512 map	add r7,r7,r4,asl#1		ldrb r8,[r6,#0]		; pixel 0,0	strb r8,[r7,#0]		ldrb r8,[r6,#8]		; pixel 0,1	strb r8,[r7,#512]			ldrb r8,[r6,#2]		; pixel 1,0	strb r8,[r7,#1]!		ldrb r8,[r6,#10]	; pixel 1,1	strb r8,[r7,#512]		b arm_generatemaps_xloop;*******************************arm_interceptplot			ROUT;*******************************; Calls a C routine to plot the temporary list if it gets full; ----------; Receives :	R0 = address of cel adder control block; Returns :		Nothing		[ Next temporary cel to add is cleared by C routine]; Corrupts :	Nothing	stmfd sp!,{r0-r3, r14}	; Store parameters	bl screen_intercept		; Call plot routine	ldmfd sp!,{r0-r3, pc}^	; Return;*******************************arm_changegamecel			ROUT;*******************************; Receives :	R0 = Address of cel data block; 				R1 = Game cel to change;				R2 = Change type				0 - Clear bits in PIXC;												1 - Set bits in PIXC;												2 - Clear bits in FLAG;												3 - Set bits in FLAG;				R3 = Bit values; Returns :		Nothing; 				[Gamecel is altered accordingly]; Corrupts :	r0-r1; ----------	ldr r0,[r0,#64]			; Base address of constant game sprites	ldr r1,[r0,r1,asl #2]	; Get offset to actual sprite data start	add r1,r0,r1			; R1 now contains actual address of Flags control word		cmp r2,#1	ldrle r0,[r1, #0]!		; Load PIXC ?	ldrge r0,[r1, #4]!		; or Load FLAG ?		tst r2,#1	orrne r0,r0,r3			; Set Bits ?	biceq r0,r0,r3			; or Clear Bits ?		str r0,[r1]				; Store flags back again	movs pc,r14	END